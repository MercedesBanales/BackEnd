declare type ValueValidationResult<TValue> = (TValue extends Array<infer TEachValue> ? Array<ValueValidationResult<TEachValue>> | string | null : TValue extends object ? {
    [propertyName in keyof TValue]?: ValueValidationResult<TValue[propertyName]>;
} | string | null : string | null) | string | null;

declare type ValidationErrors<TModel> = {
    [propertyName in keyof TModel]?: ValueValidationResult<TModel[propertyName]>;
};

interface IValidator<TModel> {
    validate: (model: TModel) => ValidationErrors<TModel>;
}

interface IAsyncValidator<TModel> {
    validateAsync: (model: TModel) => Promise<ValidationErrors<TModel>>;
}

declare type BaseValueValidators<TModel, TValue> = {
    notNull: () => RuleValidatorsAndExtensions<TModel, TValue>;
    null: () => RuleValidatorsAndExtensions<TModel, TValue>;
    notEqual: (forbiddenValue: TValue) => RuleValidatorsAndExtensions<TModel, TValue>;
    equal: (requiredValue: TValue) => RuleValidatorsAndExtensions<TModel, TValue>;
    must: (definition: ((value: TValue, model: TModel) => boolean) | {
        predicate: (value: TValue, model: TModel) => boolean;
        message: string | ((value: TValue, model: TModel) => string);
    } | Array<((value: TValue, model: TModel) => boolean) | {
        predicate: (value: TValue, model: TModel) => boolean;
        message: string | ((value: TValue, model: TModel) => string);
    }>) => RuleValidatorsAndExtensions<TModel, TValue>;
};
declare type AsyncBaseValueValidators<TModel, TValue> = BaseValueValidators<TModel, TValue> & {
    mustAsync: (definition: ((value: TValue, model: TModel) => Promise<boolean>) | {
        predicate: (value: TValue, model: TModel) => Promise<boolean>;
        message: string | ((value: TValue, model: TModel) => string);
    } | Array<((value: TValue, model: TModel) => Promise<boolean>) | {
        predicate: (value: TValue, model: TModel) => Promise<boolean>;
        message: string | ((value: TValue, model: TModel) => string);
    }>) => AsyncRuleValidatorsAndExtensions<TModel, TValue>;
    setAsyncValidator: (validatorProducer: (model: TModel) => IAsyncValidator<TValue extends null | undefined ? any : TValue>) => AsyncRuleValidatorsAndExtensions<TModel, TValue>;
};
declare type StringValueValidators<TModel, TValue extends string | null | undefined> = {
    notEmpty: () => RuleValidatorsAndExtensions<TModel, TValue>;
    length: (minLength: number, maxLength: number) => RuleValidatorsAndExtensions<TModel, TValue>;
    maxLength: (maxLength: number) => RuleValidatorsAndExtensions<TModel, TValue>;
    minLength: (minLength: number) => RuleValidatorsAndExtensions<TModel, TValue>;
    matches: (pattern: RegExp) => RuleValidatorsAndExtensions<TModel, TValue>;
    emailAddress: () => RuleValidatorsAndExtensions<TModel, TValue>;
};
declare type NumberValueValidators<TModel, TValue extends number | null | undefined> = {
    lessThan: (threshold: number) => RuleValidatorsAndExtensions<TModel, TValue>;
    lessThanOrEqualTo: (threshold: number) => RuleValidatorsAndExtensions<TModel, TValue>;
    greaterThan: (threshold: number) => RuleValidatorsAndExtensions<TModel, TValue>;
    greaterThanOrEqualTo: (threshold: number) => RuleValidatorsAndExtensions<TModel, TValue>;
    exclusiveBetween: (lowerBound: number, upperBound: number) => RuleValidatorsAndExtensions<TModel, TValue>;
    inclusiveBetween: (lowerBound: number, upperBound: number) => RuleValidatorsAndExtensions<TModel, TValue>;
    scalePrecision: (precision: number, scale: number) => RuleValidatorsAndExtensions<TModel, TValue>;
};
declare type ObjectValueValidators<TModel, TValue extends object | null | undefined> = {
    setValidator: (validatorProducer: (model: TModel) => IValidator<TValue extends null | undefined ? any : TValue>) => RuleValidatorsAndExtensions<TModel, TValue>;
};

declare type RuleValidators<TModel, TValue> = BaseValueValidators<TModel, TValue> & (TValue extends string | null | undefined ? StringValueValidators<TModel, TValue> : {}) & (TValue extends number | null | undefined ? NumberValueValidators<TModel, TValue> : {}) & (TValue extends object | null | undefined ? ObjectValueValidators<TModel, TValue> : {});
declare type AsyncRuleValidators<TModel, TValue> = RuleValidators<TModel, TValue> & AsyncBaseValueValidators<TModel, TValue>;
declare type RuleValidatorsAndConditionExtensions<TModel, TValue> = RuleValidators<TModel, TValue> & {
    when: (condition: (model: TModel) => boolean, appliesTo?: 'AppliesToAllValidators' | 'AppliesToCurrentValidator') => RuleValidators<TModel, TValue>;
    unless: (condition: (model: TModel) => boolean, appliesTo?: 'AppliesToAllValidators' | 'AppliesToCurrentValidator') => RuleValidators<TModel, TValue>;
};
declare type AsyncRuleValidatorsAndConditionExtensions<TModel, TValue> = AsyncRuleValidators<TModel, TValue> & {
    when: (condition: (model: TModel) => boolean, appliesTo?: 'AppliesToAllValidators' | 'AppliesToCurrentValidator') => AsyncRuleValidators<TModel, TValue>;
    unless: (condition: (model: TModel) => boolean, appliesTo?: 'AppliesToAllValidators' | 'AppliesToCurrentValidator') => AsyncRuleValidators<TModel, TValue>;
};
declare type RuleValidatorsAndExtensions<TModel, TValue> = RuleValidatorsAndConditionExtensions<TModel, TValue> & {
    withMessage: (message: string) => RuleValidatorsAndConditionExtensions<TModel, TValue>;
};
declare type AsyncRuleValidatorsAndExtensions<TModel, TValue> = AsyncRuleValidatorsAndConditionExtensions<TModel, TValue> & {
    withMessage: (message: string) => AsyncRuleValidatorsAndConditionExtensions<TModel, TValue>;
};

/**
 * Constrain
 * @desc Constrains type `T` to only those properties that exist in type `U`
 */
declare type Constrain<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
};

declare abstract class CoreValidator<TModel, TAsync extends true | false> {
    private _isAsync;
    constructor(isAsync: TAsync);
    private valueValidatorBuildersByPropertyName;
    private asyncValueValidatorBuildersByPropertyName;
    protected _validate: (value: TModel) => ValidationErrors<TModel>;
    protected _validateAsync: (value: TModel) => Promise<ValidationErrors<TModel>>;
    private rebuildValidate;
    private rebuildValidateAsync;
    protected ruleFor: <TPropertyName extends keyof TModel, TValue extends TModel[TPropertyName]>(propertyName: TPropertyName) => TAsync extends true ? AsyncRuleValidators<TModel, TValue> : RuleValidators<TModel, TValue>;
    protected ruleForTransformed: <TPropertyName extends keyof TModel, TValue extends TModel[TPropertyName], TTransformedValue extends string | number | boolean | symbol | TValue | null | undefined>(propertyName: TPropertyName, transformValue: (value: TValue) => TTransformedValue extends object ? Constrain<TTransformedValue, TValue> : TTransformedValue) => TAsync extends true ? AsyncRuleValidators<TModel, TTransformedValue> : RuleValidators<TModel, TTransformedValue>;
    protected ruleForEach: <TPropertyName extends keyof TModel, TValue extends TModel[TPropertyName] extends (infer TEachValue)[] | readonly (infer TEachValue)[] | null | undefined ? TModel[TPropertyName] & (TEachValue[] | readonly TEachValue[] | null | undefined) : never>(propertyName: TModel[TPropertyName] extends unknown[] | readonly unknown[] | null | undefined ? TPropertyName : never) => TValue extends unknown[] | readonly unknown[] ? TAsync extends true ? AsyncRuleValidators<TModel, TValue[0]> : RuleValidators<TModel, TValue[0]> : never;
    protected ruleForEachTransformed: <TPropertyName extends keyof TModel, TValue extends TModel[TPropertyName] extends (infer TEachValue)[] | readonly (infer TEachValue)[] | null | undefined ? TModel[TPropertyName] & (TEachValue[] | readonly TEachValue[] | null | undefined) : never, TEachTransformedValue extends string | number | boolean | symbol | (TValue extends (infer TEachValue_1)[] ? TEachValue_1 : never) | null | undefined>(propertyName: TModel[TPropertyName] extends unknown[] | readonly unknown[] | null | undefined ? TPropertyName : never, transformValue: (value: TModel[TPropertyName] extends (infer TEachValue_2)[] | readonly (infer TEachValue_2)[] ? TEachValue_2 : never) => TEachTransformedValue extends object ? Constrain<TEachTransformedValue, TModel[TPropertyName] extends (infer TEachValue_3)[] | readonly (infer TEachValue_3)[] ? TEachValue_3 : never> : TEachTransformedValue) => TValue extends unknown[] | readonly unknown[] ? TAsync extends true ? AsyncRuleValidators<TModel, TEachTransformedValue> : RuleValidators<TModel, TEachTransformedValue> : never;
}
declare class SyncValidator<TModel> extends CoreValidator<TModel, false> {
    validate: (value: TModel) => ValidationErrors<TModel>;
    constructor();
}
declare class AsyncValidator<TModel> extends CoreValidator<TModel, true> {
    validateAsync: (value: TModel) => Promise<ValidationErrors<TModel>>;
    constructor();
}

export { AsyncRuleValidators, AsyncValidator, RuleValidators, ValidationErrors, SyncValidator as Validator, ValueValidationResult };
