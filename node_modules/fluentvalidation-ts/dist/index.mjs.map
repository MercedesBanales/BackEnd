{"version":3,"sources":["../src/valueValidator/ValueValidator.ts","../src/rules/CoreRule.ts","../src/rules/AsyncRule.ts","../src/rules/MustAsyncRule.ts","../src/rules/AsyncValidatorRule.ts","../src/rules/Rule.ts","../src/rules/EmailAddressRule.ts","../src/rules/EqualRule.ts","../src/numberHelpers.ts","../src/rules/ExclusiveBetweenRule.ts","../src/rules/GreaterThanOrEqualToRule.ts","../src/rules/GreaterThanRule.ts","../src/rules/InclusiveBetweenRule.ts","../src/rules/LengthRule.ts","../src/rules/LessThanOrEqualToRule.ts","../src/rules/LessThanRule.ts","../src/rules/MatchesRule.ts","../src/rules/MaxLengthRule.ts","../src/rules/MinLengthRule.ts","../src/rules/MustRule.ts","../src/rules/NotEmptyRule.ts","../src/rules/NotEqualRule.ts","../src/rules/NotNullRule.ts","../src/rules/NullRule.ts","../src/rules/ScalePrecisionRule.ts","../src/rules/ValidatorRule.ts","../src/valueValidator/CoreValueValidatorBuilder.ts","../src/valueValidator/AsyncValueValidatorBuilder.ts","../src/valueValidator/AsyncArrayValueValidatorBuilder.ts","../src/valueValidator/ValueValidatorBuilder.ts","../src/valueValidator/ArrayValueValidatorBuilder.ts","../src/CoreValidator.ts"],"names":["hasError","valueValidationResult","eachResult","CoreRule","customErrorMessage","condition","AsyncRule","asyncValueValidator","value","model","errorOrNull","MustAsyncRule","definition","eachDefinition","predicate","message","AsyncValidatorRule","validatorProducer","Rule","valueValidator","emailAddressPattern","EmailAddressRule","EqualRule","requiredValue","formatNumber","ExclusiveBetweenRule","lowerBound","upperBound","GreaterThanOrEqualToRule","threshold","GreaterThanRule","InclusiveBetweenRule","LengthRule","minLength","maxLength","LessThanOrEqualToRule","LessThanRule","MatchesRule","pattern","MaxLengthRule","MinLengthRule","MustRule","NotEmptyRule","NotEqualRule","forbiddenValue","NotNullRule","NullRule","ScalePrecisionRule","precision","scale","scalePrecisionRegex","ValidatorRule","CoreValueValidatorBuilder","rebuildValidate","transformValue","rule","appliesTo","notEqualRule","equalRule","mustRule","notNullRule","nullRule","notEmptyRule","lengthRule","maxLengthRule","minLengthRule","matchesRule","emailAddressRule","lessThanRule","lessThanOrEqualToRule","greaterThanRule","greaterThanOrEqualToRule","exclusiveBetweenRule","inclusiveBetweenRule","validatorRule","scalePrecisionRule","AsyncValueValidatorBuilder","rebuildValidateAsync","transformedValue","validationResult","asyncMustRule","asyncValidatorRule","AsyncArrayValueValidatorBuilder","propertyName","errors","element","ValueValidatorBuilder","ArrayValueValidatorBuilder","CoreValidator","isAsync","valueValidatorBuilders","valueValidatorBuilder","result","asyncValueValidatorBuilders","asyncValueValidatorBuilder","asyncArrayValueValidatorBuilder","arrayValueValidatorBuilder","SyncValidator","AsyncValidator"],"mappings":"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","sourcesContent":["import { IValidator } from '../IValidator';\r\nimport { ValueValidationResult } from '../ValueValidationResult';\r\nimport {\r\n  RuleValidatorsAndExtensions,\r\n  AsyncRuleValidatorsAndExtensions,\r\n} from './RuleValidators';\r\nimport { IAsyncValidator } from '../IAsyncValidator';\r\n\r\nexport const hasError = <TValue>(\r\n  valueValidationResult: ValueValidationResult<TValue>\r\n): boolean => {\r\n  if (valueValidationResult == null) {\r\n    return false;\r\n  }\r\n\r\n  if (Array.isArray(valueValidationResult)) {\r\n    return (\r\n      valueValidationResult.filter((eachResult) => hasError(eachResult))\r\n        .length > 0\r\n    );\r\n  }\r\n\r\n  if (typeof valueValidationResult === 'object') {\r\n    return Object.keys(valueValidationResult as object).length > 0;\r\n  }\r\n\r\n  return valueValidationResult != null;\r\n};\r\n\r\nexport type BaseValueValidators<TModel, TValue> = {\r\n  notNull: () => RuleValidatorsAndExtensions<TModel, TValue>;\r\n  null: () => RuleValidatorsAndExtensions<TModel, TValue>;\r\n  notEqual: (\r\n    forbiddenValue: TValue\r\n  ) => RuleValidatorsAndExtensions<TModel, TValue>;\r\n  equal: (requiredValue: TValue) => RuleValidatorsAndExtensions<TModel, TValue>;\r\n  must: (\r\n    definition:\r\n      | ((value: TValue, model: TModel) => boolean)\r\n      | {\r\n          predicate: (value: TValue, model: TModel) => boolean;\r\n          message: string | ((value: TValue, model: TModel) => string);\r\n        }\r\n      | Array<\r\n          | ((value: TValue, model: TModel) => boolean)\r\n          | {\r\n              predicate: (value: TValue, model: TModel) => boolean;\r\n              message: string | ((value: TValue, model: TModel) => string);\r\n            }\r\n        >\r\n  ) => RuleValidatorsAndExtensions<TModel, TValue>;\r\n};\r\n\r\nexport type AsyncBaseValueValidators<TModel, TValue> = BaseValueValidators<\r\n  TModel,\r\n  TValue\r\n> & {\r\n  mustAsync: (\r\n    definition:\r\n      | ((value: TValue, model: TModel) => Promise<boolean>)\r\n      | {\r\n          predicate: (value: TValue, model: TModel) => Promise<boolean>;\r\n          message: string | ((value: TValue, model: TModel) => string);\r\n        }\r\n      | Array<\r\n          | ((value: TValue, model: TModel) => Promise<boolean>)\r\n          | {\r\n              predicate: (value: TValue, model: TModel) => Promise<boolean>;\r\n              message: string | ((value: TValue, model: TModel) => string);\r\n            }\r\n        >\r\n  ) => AsyncRuleValidatorsAndExtensions<TModel, TValue>;\r\n  setAsyncValidator: (\r\n    validatorProducer: (\r\n      model: TModel\r\n    ) => IAsyncValidator<TValue extends null | undefined ? any : TValue>\r\n  ) => AsyncRuleValidatorsAndExtensions<TModel, TValue>;\r\n};\r\n\r\nexport type StringValueValidators<\r\n  TModel,\r\n  TValue extends string | null | undefined\r\n> = {\r\n  notEmpty: () => RuleValidatorsAndExtensions<TModel, TValue>;\r\n  length: (\r\n    minLength: number,\r\n    maxLength: number\r\n  ) => RuleValidatorsAndExtensions<TModel, TValue>;\r\n  maxLength: (maxLength: number) => RuleValidatorsAndExtensions<TModel, TValue>;\r\n  minLength: (minLength: number) => RuleValidatorsAndExtensions<TModel, TValue>;\r\n  matches: (pattern: RegExp) => RuleValidatorsAndExtensions<TModel, TValue>;\r\n  emailAddress: () => RuleValidatorsAndExtensions<TModel, TValue>;\r\n};\r\n\r\nexport type NumberValueValidators<\r\n  TModel,\r\n  TValue extends number | null | undefined\r\n> = {\r\n  lessThan: (threshold: number) => RuleValidatorsAndExtensions<TModel, TValue>;\r\n  lessThanOrEqualTo: (\r\n    threshold: number\r\n  ) => RuleValidatorsAndExtensions<TModel, TValue>;\r\n  greaterThan: (\r\n    threshold: number\r\n  ) => RuleValidatorsAndExtensions<TModel, TValue>;\r\n  greaterThanOrEqualTo: (\r\n    threshold: number\r\n  ) => RuleValidatorsAndExtensions<TModel, TValue>;\r\n  exclusiveBetween: (\r\n    lowerBound: number,\r\n    upperBound: number\r\n  ) => RuleValidatorsAndExtensions<TModel, TValue>;\r\n  inclusiveBetween: (\r\n    lowerBound: number,\r\n    upperBound: number\r\n  ) => RuleValidatorsAndExtensions<TModel, TValue>;\r\n  scalePrecision: (\r\n    precision: number,\r\n    scale: number\r\n  ) => RuleValidatorsAndExtensions<TModel, TValue>;\r\n};\r\n\r\nexport type ObjectValueValidators<\r\n  TModel,\r\n  TValue extends object | null | undefined\r\n> = {\r\n  setValidator: (\r\n    validatorProducer: (\r\n      model: TModel\r\n    ) => IValidator<TValue extends null | undefined ? any : TValue>\r\n  ) => RuleValidatorsAndExtensions<TModel, TValue>;\r\n};\r\n","export class CoreRule<TModel> {\r\n  protected customErrorMessage?: string;\r\n  protected whenCondition?: (model: TModel) => boolean;\r\n  protected unlessCondition?: (model: TModel) => boolean;\r\n\r\n  public setCustomErrorMessage = (customErrorMessage: string): void => {\r\n    this.customErrorMessage = customErrorMessage;\r\n  };\r\n\r\n  public setWhenCondition = (condition: (model: TModel) => boolean) => {\r\n    this.whenCondition = condition;\r\n  };\r\n\r\n  public setUnlessCondition = (condition: (model: TModel) => boolean) => {\r\n    this.unlessCondition = condition;\r\n  };\r\n}\r\n","import { CoreRule } from './CoreRule';\r\nimport { AsyncValueValidator } from 'valueValidator/AsyncValueValidator';\r\nimport { ValueValidationResult } from '../ValueValidationResult';\r\n\r\nexport class AsyncRule<TModel, TValue> extends CoreRule<TModel> {\r\n  private readonly asyncValueValidator: AsyncValueValidator<\r\n    TModel,\r\n    TValue,\r\n    TValue\r\n  >;\r\n\r\n  constructor(\r\n    asyncValueValidator: AsyncValueValidator<TModel, TValue, TValue>\r\n  ) {\r\n    super();\r\n    this.asyncValueValidator = asyncValueValidator;\r\n  }\r\n\r\n  public validateAsync = async (\r\n    value: TValue,\r\n    model: TModel\r\n  ): Promise<ValueValidationResult<TValue>> => {\r\n    if (this.whenCondition != null && !this.whenCondition(model)) {\r\n      return null;\r\n    }\r\n\r\n    if (this.unlessCondition != null && this.unlessCondition(model)) {\r\n      return null;\r\n    }\r\n\r\n    const errorOrNull = await this.asyncValueValidator(value, model);\r\n    return errorOrNull != null ? this.customErrorMessage || errorOrNull : null;\r\n  };\r\n}\r\n","import { AsyncRule } from './AsyncRule';\r\n\r\nexport class MustAsyncRule<TModel, TValue> extends AsyncRule<TModel, TValue> {\r\n  constructor(\r\n    definition:\r\n      | ((value: TValue, model: TModel) => Promise<boolean>)\r\n      | {\r\n          predicate: (value: TValue, model: TModel) => Promise<boolean>;\r\n          message: string | ((value: TValue, model: TModel) => string);\r\n        }\r\n      | Array<\r\n          | ((value: TValue, model: TModel) => Promise<boolean>)\r\n          | {\r\n              predicate: (value: TValue, model: TModel) => Promise<boolean>;\r\n              message: string | ((value: TValue, model: TModel) => string);\r\n            }\r\n        >\r\n  ) {\r\n    super(async (value: TValue, model: TModel) => {\r\n      if (Array.isArray(definition)) {\r\n        for (const eachDefinition of definition) {\r\n          if (typeof eachDefinition === 'function') {\r\n            const isValid = await eachDefinition(value, model);\r\n            if (!isValid) {\r\n              return 'Value is not valid';\r\n            }\r\n          } else {\r\n            const isValid = await eachDefinition.predicate(value, model);\r\n            if (!isValid) {\r\n              return typeof eachDefinition.message === 'function'\r\n                ? eachDefinition.message(value, model)\r\n                : eachDefinition.message;\r\n            }\r\n          }\r\n        }\r\n        return null;\r\n      }\r\n\r\n      if (typeof definition === 'function') {\r\n        return (await definition(value, model)) ? null : 'Value is not valid';\r\n      }\r\n\r\n      const { predicate, message } = definition;\r\n\r\n      return (await predicate(value, model))\r\n        ? null\r\n        : typeof message === 'function'\r\n        ? message(value, model)\r\n        : message;\r\n    });\r\n  }\r\n}\r\n","import { ValueValidationResult } from '../ValueValidationResult';\r\nimport { AsyncRule } from './AsyncRule';\r\nimport { IAsyncValidator } from 'IAsyncValidator';\r\n\r\nexport class AsyncValidatorRule<TModel, TValue> extends AsyncRule<\r\n  TModel,\r\n  TValue\r\n> {\r\n  constructor(validatorProducer: (model: TModel) => IAsyncValidator<TValue>) {\r\n    super(async (value: TValue, model: TModel) =>\r\n      value == null\r\n        ? Promise.resolve(null)\r\n        : ((await validatorProducer(model).validateAsync(\r\n            value\r\n          )) as ValueValidationResult<TValue>)\r\n    );\r\n  }\r\n}\r\n","import { CoreRule } from './CoreRule';\r\nimport { ValueValidationResult } from '../ValueValidationResult';\r\nimport { ValueValidator } from '../ValueValidator';\r\n\r\nexport class Rule<TModel, TValue> extends CoreRule<TModel> {\r\n  private readonly valueValidator: ValueValidator<TModel, TValue>;\r\n\r\n  constructor(valueValidator: ValueValidator<TModel, TValue>) {\r\n    super();\r\n    this.valueValidator = valueValidator;\r\n  }\r\n\r\n  public validate = (\r\n    value: TValue,\r\n    model: TModel\r\n  ): ValueValidationResult<TValue> => {\r\n    if (this.whenCondition != null && !this.whenCondition(model)) {\r\n      return null;\r\n    }\r\n\r\n    if (this.unlessCondition != null && this.unlessCondition(model)) {\r\n      return null;\r\n    }\r\n\r\n    const errorOrNull = this.valueValidator(value, model);\r\n    return errorOrNull != null ? this.customErrorMessage || errorOrNull : null;\r\n  };\r\n}\r\n","import { Rule } from './Rule';\r\n\r\nconst emailAddressPattern =\r\n  /^[a-zA-Z0-9.!#$%&’\"*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)+$/;\r\n\r\nexport class EmailAddressRule<TModel, TValue> extends Rule<TModel, TValue> {\r\n  constructor() {\r\n    super((value: TValue) => {\r\n      if (value == null) {\r\n        return null;\r\n      }\r\n      if (typeof value !== 'string') {\r\n        throw new TypeError(\r\n          'A non-string value was passed to the emailAddress rule'\r\n        );\r\n      }\r\n      return emailAddressPattern.test(value)\r\n        ? null\r\n        : 'Not a valid email address';\r\n    });\r\n  }\r\n}\r\n","import { Rule } from './Rule';\r\n\r\nexport class EqualRule<TModel, TValue> extends Rule<TModel, TValue> {\r\n  constructor(requiredValue: TValue) {\r\n    super((value: TValue) =>\r\n      value === requiredValue ? null : `Must equal '${requiredValue}'`\r\n    );\r\n  }\r\n}\r\n","export const formatNumber = (value: number) =>\r\n  value.toLocaleString(undefined, { maximumFractionDigits: 20 });\r\n","import { formatNumber } from '../numberHelpers';\r\nimport { Rule } from './Rule';\r\n\r\nexport class ExclusiveBetweenRule<TModel, TValue> extends Rule<TModel, TValue> {\r\n  constructor(lowerBound: number, upperBound: number) {\r\n    super((value: TValue) => {\r\n      if (value == null) {\r\n        return null;\r\n      }\r\n      if (typeof value !== 'number') {\r\n        throw new TypeError(\r\n          'A non-number value was passed to the exclusiveBetween rule'\r\n        );\r\n      }\r\n      return value > lowerBound && value < upperBound\r\n        ? null\r\n        : `Value must be between ${formatNumber(lowerBound)} and ${formatNumber(\r\n            upperBound\r\n          )} (exclusive)`;\r\n    });\r\n  }\r\n}\r\n","import { formatNumber } from '../numberHelpers';\r\nimport { Rule } from './Rule';\r\n\r\nexport class GreaterThanOrEqualToRule<TModel, TValue> extends Rule<\r\n  TModel,\r\n  TValue\r\n> {\r\n  constructor(threshold: number) {\r\n    super((value: TValue) => {\r\n      if (value == null) {\r\n        return null;\r\n      }\r\n      if (typeof value !== 'number') {\r\n        throw new TypeError(\r\n          'A non-number value was passed to the greaterThanOrEqualTo rule'\r\n        );\r\n      }\r\n      return value >= threshold\r\n        ? null\r\n        : `Value must be greater than or equal to ${formatNumber(threshold)}`;\r\n    });\r\n  }\r\n}\r\n","import { formatNumber } from '../numberHelpers';\r\nimport { Rule } from './Rule';\r\n\r\nexport class GreaterThanRule<TModel, TValue> extends Rule<TModel, TValue> {\r\n  constructor(threshold: number) {\r\n    super((value: TValue) => {\r\n      if (value == null) {\r\n        return null;\r\n      }\r\n      if (typeof value !== 'number') {\r\n        throw new TypeError(\r\n          'A non-number value was passed to the greaterThan rule'\r\n        );\r\n      }\r\n      return value > threshold\r\n        ? null\r\n        : `Value must be greater than ${formatNumber(threshold)}`;\r\n    });\r\n  }\r\n}\r\n","import { formatNumber } from '../numberHelpers';\r\nimport { Rule } from './Rule';\r\n\r\nexport class InclusiveBetweenRule<TModel, TValue> extends Rule<TModel, TValue> {\r\n  constructor(lowerBound: number, upperBound: number) {\r\n    super((value: TValue) => {\r\n      if (value == null) {\r\n        return null;\r\n      }\r\n      if (typeof value !== 'number') {\r\n        throw new TypeError(\r\n          'A non-number value was passed to the inclusiveBetween rule'\r\n        );\r\n      }\r\n      return value >= lowerBound && value <= upperBound\r\n        ? null\r\n        : `Value must be between ${formatNumber(lowerBound)} and ${formatNumber(\r\n            upperBound\r\n          )} (inclusive)`;\r\n    });\r\n  }\r\n}\r\n","import { formatNumber } from '../numberHelpers';\r\nimport { Rule } from './Rule';\r\n\r\nexport class LengthRule<TModel, TValue> extends Rule<TModel, TValue> {\r\n  constructor(minLength: number, maxLength: number) {\r\n    super((value: TValue) => {\r\n      if (value == null) {\r\n        return null;\r\n      }\r\n      if (typeof value !== 'string') {\r\n        throw new TypeError('A non-string value was passed to the length rule');\r\n      }\r\n      return value.length >= minLength && value.length <= maxLength\r\n        ? null\r\n        : `Value must be between ${formatNumber(minLength)} and ${formatNumber(\r\n            maxLength\r\n          )} characters long`;\r\n    });\r\n  }\r\n}\r\n","import { formatNumber } from '../numberHelpers';\r\nimport { Rule } from './Rule';\r\n\r\nexport class LessThanOrEqualToRule<TModel, TValue> extends Rule<\r\n  TModel,\r\n  TValue\r\n> {\r\n  constructor(threshold: number) {\r\n    super((value: TValue) => {\r\n      if (value == null) {\r\n        return null;\r\n      }\r\n      if (typeof value !== 'number') {\r\n        throw new TypeError(\r\n          'A non-number value was passed to the lessThanOrEqualTo rule'\r\n        );\r\n      }\r\n      return value <= threshold\r\n        ? null\r\n        : `Value must be less than or equal to ${formatNumber(threshold)}`;\r\n    });\r\n  }\r\n}\r\n","import { formatNumber } from '../numberHelpers';\r\nimport { Rule } from './Rule';\r\n\r\nexport class LessThanRule<TModel, TValue> extends Rule<TModel, TValue> {\r\n  constructor(threshold: number) {\r\n    super((value: TValue) => {\r\n      if (value == null) {\r\n        return null;\r\n      }\r\n      if (typeof value !== 'number') {\r\n        throw new TypeError(\r\n          'A non-number value was passed to the lessThan rule'\r\n        );\r\n      }\r\n      return value < threshold\r\n        ? null\r\n        : `Value must be less than ${formatNumber(threshold)}`;\r\n    });\r\n  }\r\n}\r\n","import { Rule } from './Rule';\r\n\r\nexport class MatchesRule<TModel, TValue> extends Rule<TModel, TValue> {\r\n  constructor(pattern: RegExp) {\r\n    super((value: TValue) => {\r\n      if (value == null) {\r\n        return null;\r\n      }\r\n      if (typeof value !== 'string') {\r\n        throw new TypeError(\r\n          'A non-string value was passed to the matches rule'\r\n        );\r\n      }\r\n      return pattern.test(value)\r\n        ? null\r\n        : 'Value does not match the required pattern';\r\n    });\r\n  }\r\n}\r\n","import { formatNumber } from '../numberHelpers';\r\nimport { Rule } from './Rule';\r\n\r\nexport class MaxLengthRule<TModel, TValue> extends Rule<TModel, TValue> {\r\n  constructor(maxLength: number) {\r\n    super((value: TValue) => {\r\n      if (value == null) {\r\n        return null;\r\n      }\r\n      if (typeof value !== 'string') {\r\n        throw new TypeError(\r\n          'A non-string value was passed to the maxLength rule'\r\n        );\r\n      }\r\n      return value.length <= maxLength\r\n        ? null\r\n        : `Value must be no more than ${formatNumber(\r\n            maxLength\r\n          )} characters long`;\r\n    });\r\n  }\r\n}\r\n","import { formatNumber } from '../numberHelpers';\r\nimport { Rule } from './Rule';\r\n\r\nexport class MinLengthRule<TModel, TValue> extends Rule<TModel, TValue> {\r\n  constructor(minLength: number) {\r\n    super((value: TValue) => {\r\n      if (value == null) {\r\n        return null;\r\n      }\r\n      if (typeof value !== 'string') {\r\n        throw new TypeError(\r\n          'A non-string value was passed to the minLength rule'\r\n        );\r\n      }\r\n      return value.length >= minLength\r\n        ? null\r\n        : `Value must be at least ${formatNumber(minLength)} characters long`;\r\n    });\r\n  }\r\n}\r\n","import { Rule } from './Rule';\r\n\r\nexport class MustRule<TModel, TValue> extends Rule<TModel, TValue> {\r\n  constructor(\r\n    definition:\r\n      | ((value: TValue, model: TModel) => boolean)\r\n      | {\r\n          predicate: (value: TValue, model: TModel) => boolean;\r\n          message: string | ((value: TValue, model: TModel) => string);\r\n        }\r\n      | Array<\r\n          | ((value: TValue, model: TModel) => boolean)\r\n          | {\r\n              predicate: (value: TValue, model: TModel) => boolean;\r\n              message: string | ((value: TValue, model: TModel) => string);\r\n            }\r\n        >\r\n  ) {\r\n    super((value: TValue, model: TModel) => {\r\n      if (Array.isArray(definition)) {\r\n        for (const eachDefinition of definition) {\r\n          if (typeof eachDefinition === 'function') {\r\n            const isValid = eachDefinition(value, model);\r\n            if (!isValid) {\r\n              return 'Value is not valid';\r\n            }\r\n          } else {\r\n            const isValid = eachDefinition.predicate(value, model);\r\n            if (!isValid) {\r\n              return typeof eachDefinition.message === 'function'\r\n                ? eachDefinition.message(value, model)\r\n                : eachDefinition.message;\r\n            }\r\n          }\r\n        }\r\n        return null;\r\n      }\r\n\r\n      if (typeof definition === 'function') {\r\n        return definition(value, model) ? null : 'Value is not valid';\r\n      }\r\n\r\n      const { predicate, message } = definition;\r\n\r\n      return predicate(value, model)\r\n        ? null\r\n        : typeof message === 'function'\r\n        ? message(value, model)\r\n        : message;\r\n    });\r\n  }\r\n}\r\n","import { Rule } from './Rule';\r\n\r\nexport class NotEmptyRule<TModel, TValue> extends Rule<TModel, TValue> {\r\n  constructor() {\r\n    super((value: TValue) => {\r\n      if (typeof value !== 'string') {\r\n        if (value == null) {\r\n          return null;\r\n        }\r\n        throw new TypeError(\r\n          'A non-string value was passed to the notEmpty rule'\r\n        );\r\n      }\r\n      return value.trim().length > 0 ? null : 'Value cannot be empty';\r\n    });\r\n  }\r\n}\r\n","import { Rule } from './Rule';\r\n\r\nexport class NotEqualRule<TModel, TValue> extends Rule<TModel, TValue> {\r\n  constructor(forbiddenValue: TValue) {\r\n    super((value: TValue) =>\r\n      value !== forbiddenValue ? null : `Must not equal '${forbiddenValue}'`\r\n    );\r\n  }\r\n}\r\n","import { Rule } from './Rule';\r\n\r\nexport class NotNullRule<TModel, TValue> extends Rule<TModel, TValue> {\r\n  constructor() {\r\n    super((value: TValue) => (value != null ? null : 'Value cannot be null'));\r\n  }\r\n}\r\n","import { Rule } from './Rule';\r\n\r\nexport class NullRule<TModel, TValue> extends Rule<TModel, TValue> {\r\n  constructor() {\r\n    super((value: TValue) => (value == null ? null : 'Value must be null'));\r\n  }\r\n}\r\n","import { Rule } from './Rule';\r\n\r\nexport class ScalePrecisionRule<TModel, TValue> extends Rule<TModel, TValue> {\r\n  constructor(precision: number, scale: number) {\r\n    super((value: TValue) => {\r\n      if (value == null) {\r\n        return null;\r\n      }\r\n      if (typeof value !== 'number') {\r\n        throw new TypeError(\r\n          'A non-number value was passed to the scalePrecision rule'\r\n        );\r\n      }\r\n      const regex = scalePrecisionRegex(scale, precision);\r\n      if (!regex.test(value.toString())) {\r\n        return `Value must not be more than ${scale} digits in total, with allowance for ${precision} decimals`;\r\n      }\r\n      return null;\r\n    });\r\n  }\r\n}\r\n\r\nconst scalePrecisionRegex = (scale: number, precision: number) =>\r\n  new RegExp(\r\n    `^(-)?([0-9]){0,${scale - precision}}(\\\\.[0-9]{0,${precision}})?$`\r\n  );\r\n","import { IValidator } from '../IValidator';\r\nimport { ValueValidationResult } from '../ValueValidationResult';\r\nimport { Rule } from './Rule';\r\n\r\nexport class ValidatorRule<TModel, TValue> extends Rule<TModel, TValue> {\r\n  constructor(validatorProducer: (model: TModel) => IValidator<TValue>) {\r\n    super((value: TValue, model: TModel) =>\r\n      value == null\r\n        ? null\r\n        : (validatorProducer(model).validate(\r\n            value\r\n          ) as ValueValidationResult<TValue>)\r\n    );\r\n  }\r\n}\r\n","import { IValidator } from '../IValidator';\r\nimport { AsyncRule } from '../rules/AsyncRule';\r\nimport { EmailAddressRule } from '../rules/EmailAddressRule';\r\nimport { EqualRule } from '../rules/EqualRule';\r\nimport { ExclusiveBetweenRule } from '../rules/ExclusiveBetweenRule';\r\nimport { GreaterThanOrEqualToRule } from '../rules/GreaterThanOrEqualToRule';\r\nimport { GreaterThanRule } from '../rules/GreaterThanRule';\r\nimport { InclusiveBetweenRule } from '../rules/InclusiveBetweenRule';\r\nimport { LengthRule } from '../rules/LengthRule';\r\nimport { LessThanOrEqualToRule } from '../rules/LessThanOrEqualToRule';\r\nimport { LessThanRule } from '../rules/LessThanRule';\r\nimport { MatchesRule } from '../rules/MatchesRule';\r\nimport { MaxLengthRule } from '../rules/MaxLengthRule';\r\nimport { MinLengthRule } from '../rules/MinLengthRule';\r\nimport { MustRule } from '../rules/MustRule';\r\nimport { NotEmptyRule } from '../rules/NotEmptyRule';\r\nimport { NotEqualRule } from '../rules/NotEqualRule';\r\nimport { NotNullRule } from '../rules/NotNullRule';\r\nimport { NullRule } from '../rules/NullRule';\r\nimport { Rule } from '../rules/Rule';\r\nimport { ScalePrecisionRule } from '../rules/ScalePrecisionRule';\r\nimport { ValidatorRule } from '../rules/ValidatorRule';\r\nimport { ValueTransformer } from './ValueTransformer';\r\n\r\nexport abstract class CoreValueValidatorBuilder<\r\n  TModel,\r\n  TValue,\r\n  TTransformedValue\r\n> {\r\n  protected rules: Array<{\r\n    isAsync: boolean;\r\n    rule:\r\n      | Rule<TModel, TTransformedValue>\r\n      | AsyncRule<TModel, TTransformedValue>;\r\n  }> = [];\r\n\r\n  private rebuildValidate: () => void;\r\n\r\n  protected transformValue: ValueTransformer<TValue, TTransformedValue>;\r\n\r\n  constructor(\r\n    rebuildValidate: () => void,\r\n    transformValue: ValueTransformer<TValue, TTransformedValue>\r\n  ) {\r\n    this.rebuildValidate = rebuildValidate;\r\n    this.transformValue = transformValue;\r\n  }\r\n\r\n  protected pushRule = (rule: Rule<TModel, TTransformedValue>) => {\r\n    this.rules.push({ isAsync: false, rule });\r\n    this.rebuildValidate();\r\n  };\r\n\r\n  protected pushAsyncRule = (rule: AsyncRule<TModel, TTransformedValue>) => {\r\n    this.rules.push({ isAsync: true, rule });\r\n    this.rebuildValidate();\r\n  };\r\n\r\n  public withMessage = (message: string) => {\r\n    const latestRule = this.getLatestRule();\r\n    latestRule.rule.setCustomErrorMessage(message);\r\n\r\n    this.rebuildValidate();\r\n\r\n    return {\r\n      ...this.getAllRules(),\r\n      when: this.when,\r\n      unless: this.unless,\r\n    };\r\n  };\r\n\r\n  public when = (\r\n    condition: (model: TModel) => boolean,\r\n    appliesTo:\r\n      | 'AppliesToAllValidators'\r\n      | 'AppliesToCurrentValidator' = 'AppliesToAllValidators'\r\n  ) => {\r\n    if (appliesTo === 'AppliesToAllValidators') {\r\n      for (const rule of this.rules) {\r\n        rule.rule.setWhenCondition(condition);\r\n      }\r\n    } else {\r\n      const latestRule = this.getLatestRule();\r\n      latestRule.rule.setWhenCondition(condition);\r\n    }\r\n    this.rebuildValidate();\r\n    return this.getAllRules();\r\n  };\r\n\r\n  public unless = (\r\n    condition: (model: TModel) => boolean,\r\n    appliesTo:\r\n      | 'AppliesToAllValidators'\r\n      | 'AppliesToCurrentValidator' = 'AppliesToAllValidators'\r\n  ) => {\r\n    if (appliesTo === 'AppliesToAllValidators') {\r\n      for (const rule of this.rules) {\r\n        rule.rule.setUnlessCondition(condition);\r\n      }\r\n    } else {\r\n      const latestRule = this.getLatestRule();\r\n      latestRule.rule.setUnlessCondition(condition);\r\n    }\r\n    this.rebuildValidate();\r\n    return this.getAllRules();\r\n  };\r\n\r\n  public notEqual = (forbiddenValue: TTransformedValue) => {\r\n    const notEqualRule = new NotEqualRule<TModel, TTransformedValue>(\r\n      forbiddenValue\r\n    );\r\n    this.pushRule(notEqualRule);\r\n    return this.getAllRulesAndExtensions();\r\n  };\r\n\r\n  public equal = (requiredValue: TTransformedValue) => {\r\n    const equalRule = new EqualRule<TModel, TTransformedValue>(requiredValue);\r\n    this.pushRule(equalRule);\r\n    return this.getAllRulesAndExtensions();\r\n  };\r\n\r\n  public must = (\r\n    definition:\r\n      | ((value: TTransformedValue, model: TModel) => boolean)\r\n      | {\r\n          predicate: (value: TTransformedValue, model: TModel) => boolean;\r\n          message:\r\n            | string\r\n            | ((value: TTransformedValue, model: TModel) => string);\r\n        }\r\n      | Array<\r\n          | ((value: TTransformedValue, model: TModel) => boolean)\r\n          | {\r\n              predicate: (value: TTransformedValue, model: TModel) => boolean;\r\n              message:\r\n                | string\r\n                | ((value: TTransformedValue, model: TModel) => string);\r\n            }\r\n        >\r\n  ) => {\r\n    const mustRule = new MustRule<TModel, TTransformedValue>(definition);\r\n    this.pushRule(mustRule);\r\n    return this.getAllRulesAndExtensions();\r\n  };\r\n\r\n  public notNull = () => {\r\n    const notNullRule = new NotNullRule<TModel, TTransformedValue>();\r\n    this.pushRule(notNullRule);\r\n    return this.getAllRulesAndExtensions();\r\n  };\r\n\r\n  public null = () => {\r\n    const nullRule = new NullRule<TModel, TTransformedValue>();\r\n    this.pushRule(nullRule);\r\n    return this.getAllRulesAndExtensions();\r\n  };\r\n\r\n  public notEmpty = () => {\r\n    const notEmptyRule = new NotEmptyRule<TModel, TTransformedValue>();\r\n    this.pushRule(notEmptyRule);\r\n    return this.getAllRulesAndExtensions();\r\n  };\r\n\r\n  public length = (minLength: number, maxLength: number) => {\r\n    const lengthRule = new LengthRule<TModel, TTransformedValue>(\r\n      minLength,\r\n      maxLength\r\n    );\r\n    this.pushRule(lengthRule);\r\n    return this.getAllRulesAndExtensions();\r\n  };\r\n\r\n  public maxLength = (maxLength: number) => {\r\n    const maxLengthRule = new MaxLengthRule<TModel, TTransformedValue>(\r\n      maxLength\r\n    );\r\n    this.pushRule(maxLengthRule);\r\n    return this.getAllRulesAndExtensions();\r\n  };\r\n\r\n  public minLength = (minLength: number) => {\r\n    const minLengthRule = new MinLengthRule<TModel, TTransformedValue>(\r\n      minLength\r\n    );\r\n    this.pushRule(minLengthRule);\r\n    return this.getAllRulesAndExtensions();\r\n  };\r\n\r\n  public matches = (pattern: RegExp) => {\r\n    const matchesRule = new MatchesRule<TModel, TTransformedValue>(pattern);\r\n    this.pushRule(matchesRule);\r\n    return this.getAllRulesAndExtensions();\r\n  };\r\n\r\n  public emailAddress = () => {\r\n    const emailAddressRule = new EmailAddressRule<TModel, TTransformedValue>();\r\n    this.pushRule(emailAddressRule);\r\n    return this.getAllRulesAndExtensions();\r\n  };\r\n\r\n  public lessThan = (threshold: number) => {\r\n    const lessThanRule = new LessThanRule<TModel, TTransformedValue>(threshold);\r\n    this.pushRule(lessThanRule);\r\n    return this.getAllRulesAndExtensions();\r\n  };\r\n\r\n  public lessThanOrEqualTo = (threshold: number) => {\r\n    const lessThanOrEqualToRule = new LessThanOrEqualToRule<\r\n      TModel,\r\n      TTransformedValue\r\n    >(threshold);\r\n    this.pushRule(lessThanOrEqualToRule);\r\n    return this.getAllRulesAndExtensions();\r\n  };\r\n\r\n  public greaterThan = (threshold: number) => {\r\n    const greaterThanRule = new GreaterThanRule<TModel, TTransformedValue>(\r\n      threshold\r\n    );\r\n    this.pushRule(greaterThanRule);\r\n    return this.getAllRulesAndExtensions();\r\n  };\r\n\r\n  public greaterThanOrEqualTo = (threshold: number) => {\r\n    const greaterThanOrEqualToRule = new GreaterThanOrEqualToRule<\r\n      TModel,\r\n      TTransformedValue\r\n    >(threshold);\r\n    this.pushRule(greaterThanOrEqualToRule);\r\n    return this.getAllRulesAndExtensions();\r\n  };\r\n\r\n  public exclusiveBetween = (lowerBound: number, upperBound: number) => {\r\n    const exclusiveBetweenRule = new ExclusiveBetweenRule<\r\n      TModel,\r\n      TTransformedValue\r\n    >(lowerBound, upperBound);\r\n    this.pushRule(exclusiveBetweenRule);\r\n    return this.getAllRulesAndExtensions();\r\n  };\r\n\r\n  public inclusiveBetween = (lowerBound: number, upperBound: number) => {\r\n    const inclusiveBetweenRule = new InclusiveBetweenRule<\r\n      TModel,\r\n      TTransformedValue\r\n    >(lowerBound, upperBound);\r\n    this.pushRule(inclusiveBetweenRule);\r\n    return this.getAllRulesAndExtensions();\r\n  };\r\n\r\n  public setValidator = (\r\n    validatorProducer: (model: TModel) => IValidator<TTransformedValue>\r\n  ) => {\r\n    const validatorRule = new ValidatorRule<TModel, TTransformedValue>(\r\n      validatorProducer as (model: TModel) => IValidator<TTransformedValue>\r\n    );\r\n    this.pushRule(validatorRule);\r\n    return this.getAllRulesAndExtensions();\r\n  };\r\n\r\n  public scalePrecision = (precision: number, scale: number) => {\r\n    if (scale - precision <= 0) {\r\n      throw new Error(\r\n        'Invalid scale and precision were passed to the scalePrecision rule'\r\n      );\r\n    }\r\n    const scalePrecisionRule = new ScalePrecisionRule<\r\n      TModel,\r\n      TTransformedValue\r\n    >(precision, scale);\r\n    this.pushRule(scalePrecisionRule);\r\n    return this.getAllRulesAndExtensions();\r\n  };\r\n\r\n  protected _getAllRules = () => {\r\n    return {\r\n      notEqual: this.notEqual,\r\n      equal: this.equal,\r\n      must: this.must,\r\n      notNull: this.notNull,\r\n      null: this.null,\r\n      notEmpty: this.notEmpty,\r\n      length: this.length,\r\n      maxLength: this.maxLength,\r\n      minLength: this.minLength,\r\n      matches: this.matches,\r\n      emailAddress: this.emailAddress,\r\n      lessThan: this.lessThan,\r\n      lessThanOrEqualTo: this.lessThanOrEqualTo,\r\n      greaterThan: this.greaterThan,\r\n      greaterThanOrEqualTo: this.greaterThanOrEqualTo,\r\n      exclusiveBetween: this.exclusiveBetween,\r\n      inclusiveBetween: this.inclusiveBetween,\r\n      setValidator: this.setValidator,\r\n      scalePrecision: this.scalePrecision,\r\n    };\r\n  };\r\n\r\n  // We don't care about code coverage for this line\r\n  // istanbul ignore next\r\n  public abstract getAllRules = (): object => {\r\n    throw new Error(\r\n      'getAllRules on CoreValueValidatorBuilder is an abstract method and should never be called'\r\n    );\r\n  };\r\n\r\n  public getAllRulesAndExtensions = () => {\r\n    return {\r\n      ...this.getAllRules(),\r\n      withMessage: this.withMessage,\r\n      when: this.when,\r\n      unless: this.unless,\r\n    };\r\n  };\r\n\r\n  private getLatestRule = () => {\r\n    return this.rules[this.rules.length - 1];\r\n  };\r\n}\r\n","import { AsyncValueValidator } from './AsyncValueValidator';\r\nimport { AsyncRule } from '../rules/AsyncRule';\r\nimport { MustAsyncRule } from '../rules/MustAsyncRule';\r\nimport { Rule } from '../rules/Rule';\r\nimport { ValueValidationResult } from '../ValueValidationResult';\r\nimport { hasError } from './ValueValidator';\r\nimport { IAsyncValidator } from '../IAsyncValidator';\r\nimport { AsyncValidatorRule } from '../rules/AsyncValidatorRule';\r\nimport { CoreValueValidatorBuilder } from './CoreValueValidatorBuilder';\r\nimport { ValueTransformer } from './ValueTransformer';\r\n\r\nexport class AsyncValueValidatorBuilder<\r\n  TModel,\r\n  TValue,\r\n  TTransformedValue\r\n> extends CoreValueValidatorBuilder<TModel, TValue, TTransformedValue> {\r\n  constructor(\r\n    rebuildValidateAsync: () => void,\r\n    transformValue: ValueTransformer<TValue, TTransformedValue>\r\n  ) {\r\n    super(rebuildValidateAsync, transformValue);\r\n  }\r\n\r\n  public build = (): AsyncValueValidator<TModel, TValue, TTransformedValue> => {\r\n    return async (\r\n      value: TValue,\r\n      model: TModel\r\n    ): Promise<ValueValidationResult<TTransformedValue>> => {\r\n      const transformedValue = this.transformValue(value);\r\n\r\n      for (const rule of this.rules) {\r\n        const validationResult = rule.isAsync\r\n          ? await (\r\n              rule.rule as AsyncRule<TModel, TTransformedValue>\r\n            ).validateAsync(transformedValue, model)\r\n          : (rule.rule as Rule<TModel, TTransformedValue>).validate(\r\n              transformedValue,\r\n              model\r\n            );\r\n\r\n        if (hasError(validationResult)) {\r\n          return validationResult;\r\n        }\r\n      }\r\n\r\n      return null;\r\n    };\r\n  };\r\n\r\n  public mustAsync = (\r\n    definition:\r\n      | ((value: TTransformedValue, model: TModel) => Promise<boolean>)\r\n      | {\r\n          predicate: (\r\n            value: TTransformedValue,\r\n            model: TModel\r\n          ) => Promise<boolean>;\r\n          message:\r\n            | string\r\n            | ((value: TTransformedValue, model: TModel) => string);\r\n        }\r\n      | Array<\r\n          | ((value: TTransformedValue, model: TModel) => Promise<boolean>)\r\n          | {\r\n              predicate: (\r\n                value: TTransformedValue,\r\n                model: TModel\r\n              ) => Promise<boolean>;\r\n              message:\r\n                | string\r\n                | ((value: TTransformedValue, model: TModel) => string);\r\n            }\r\n        >\r\n  ) => {\r\n    const asyncMustRule = new MustAsyncRule<TModel, TTransformedValue>(\r\n      definition\r\n    );\r\n    this.pushAsyncRule(asyncMustRule);\r\n    return this.getAllRulesAndExtensions();\r\n  };\r\n\r\n  public setAsyncValidator = (\r\n    validatorProducer: (model: TModel) => IAsyncValidator<TTransformedValue>\r\n  ) => {\r\n    const asyncValidatorRule = new AsyncValidatorRule<\r\n      TModel,\r\n      TTransformedValue\r\n    >(\r\n      validatorProducer as (model: TModel) => IAsyncValidator<TTransformedValue>\r\n    );\r\n    this.pushAsyncRule(asyncValidatorRule);\r\n    return this.getAllRulesAndExtensions();\r\n  };\r\n\r\n  public getAllRules = () => {\r\n    return {\r\n      ...this._getAllRules(),\r\n      mustAsync: this.mustAsync,\r\n      setAsyncValidator: this.setAsyncValidator,\r\n    };\r\n  };\r\n}\r\n","import { AsyncValueValidator } from 'valueValidator/AsyncValueValidator';\r\nimport { ValueValidationResult } from '../ValueValidationResult';\r\nimport { hasError } from '../valueValidator/ValueValidator';\r\nimport { AsyncValueValidatorBuilder } from './AsyncValueValidatorBuilder';\r\nimport { ValueTransformer } from './ValueTransformer';\r\n\r\nexport class AsyncArrayValueValidatorBuilder<\r\n  TModel,\r\n  TPropertyName extends keyof TModel,\r\n  TValue extends Array<TEachValue> & TModel[TPropertyName],\r\n  TEachValue,\r\n  TEachTransformedValue\r\n> {\r\n  private eachAsyncValueValidatorBuilder: AsyncValueValidatorBuilder<\r\n    TModel,\r\n    TValue[0] & TEachValue,\r\n    TEachTransformedValue\r\n  >;\r\n\r\n  private propertyName: string;\r\n\r\n  constructor(\r\n    rebuildValidateAsync: () => void,\r\n    propertyName: string,\r\n    transformValue: ValueTransformer<TEachValue, TEachTransformedValue>\r\n  ) {\r\n    this.eachAsyncValueValidatorBuilder = new AsyncValueValidatorBuilder<\r\n      TModel,\r\n      TValue[0] & TEachValue,\r\n      TEachTransformedValue\r\n    >(rebuildValidateAsync, transformValue);\r\n\r\n    this.propertyName = propertyName;\r\n  }\r\n\r\n  public build = (): AsyncValueValidator<\r\n    TModel,\r\n    TValue,\r\n    Array<TEachTransformedValue>\r\n  > => {\r\n    return async (value: TValue, model: TModel) => {\r\n      if (model[this.propertyName as TPropertyName] == null) {\r\n        return null;\r\n      }\r\n\r\n      const asyncValueValidator = this.eachAsyncValueValidatorBuilder.build();\r\n\r\n      const errors = [];\r\n\r\n      for (const element of value) {\r\n        const errorOrNull = await asyncValueValidator(element, model);\r\n        const valueValidationResult = hasError(errorOrNull)\r\n          ? errorOrNull\r\n          : null;\r\n        errors.push(valueValidationResult);\r\n      }\r\n\r\n      return (\r\n        hasError<Array<TEachTransformedValue>>(\r\n          errors as ValueValidationResult<Array<TEachTransformedValue>>\r\n        )\r\n          ? errors\r\n          : null\r\n      ) as ValueValidationResult<Array<TEachTransformedValue>>;\r\n    };\r\n  };\r\n\r\n  public getAllRules = () => this.eachAsyncValueValidatorBuilder.getAllRules();\r\n}\r\n","import { Rule } from '../rules/Rule';\r\nimport { ValueValidationResult } from '../ValueValidationResult';\r\nimport { hasError } from './ValueValidator';\r\nimport { ValueValidator } from '../ValueValidator';\r\nimport { CoreValueValidatorBuilder } from './CoreValueValidatorBuilder';\r\nimport { ValueTransformer } from './ValueTransformer';\r\n\r\nexport class ValueValidatorBuilder<\r\n  TModel,\r\n  TValue,\r\n  TTransformedValue extends\r\n    | TValue\r\n    | string\r\n    | number\r\n    | boolean\r\n    | null\r\n    | undefined\r\n    | symbol\r\n> extends CoreValueValidatorBuilder<TModel, TValue, TTransformedValue> {\r\n  constructor(\r\n    rebuildValidate: () => void,\r\n    transformValue: ValueTransformer<TValue, TTransformedValue>\r\n  ) {\r\n    super(rebuildValidate, transformValue);\r\n  }\r\n\r\n  public build = (): ValueValidator<TModel, TValue> => {\r\n    return (value: TValue, model: TModel): ValueValidationResult<TValue> => {\r\n      const transformedValue = this.transformValue(value);\r\n\r\n      for (const rule of this.rules) {\r\n        const validationResult = (\r\n          rule.rule as Rule<TModel, TTransformedValue>\r\n        ).validate(transformedValue, model) as ValueValidationResult<TValue>;\r\n\r\n        if (hasError(validationResult)) {\r\n          return validationResult;\r\n        }\r\n      }\r\n\r\n      return null;\r\n    };\r\n  };\r\n\r\n  public getAllRules = () => {\r\n    return {\r\n      ...this._getAllRules(),\r\n    };\r\n  };\r\n}\r\n","import { ValueValidationResult } from '../ValueValidationResult';\r\nimport { ValueValidator } from '../ValueValidator';\r\nimport { ValueTransformer } from './ValueTransformer';\r\nimport { hasError } from './ValueValidator';\r\nimport { ValueValidatorBuilder } from './ValueValidatorBuilder';\r\n\r\nexport class ArrayValueValidatorBuilder<\r\n  TModel,\r\n  TPropertyName extends keyof TModel,\r\n  TValue extends Array<TEachValue> & TModel[TPropertyName],\r\n  TEachValue,\r\n  TEachTransformedValue extends\r\n    | TEachValue\r\n    | string\r\n    | number\r\n    | boolean\r\n    | null\r\n    | undefined\r\n    | symbol\r\n> {\r\n  private eachValueValidatorBuilder: ValueValidatorBuilder<\r\n    TModel,\r\n    TEachValue,\r\n    TEachTransformedValue\r\n  >;\r\n\r\n  private propertyName: string;\r\n\r\n  constructor(\r\n    rebuildValidate: () => void,\r\n    propertyName: string,\r\n    transformValue: ValueTransformer<TEachValue, TEachTransformedValue>\r\n  ) {\r\n    this.eachValueValidatorBuilder = new ValueValidatorBuilder<\r\n      TModel,\r\n      TEachValue,\r\n      TEachTransformedValue\r\n    >(rebuildValidate, transformValue);\r\n\r\n    this.propertyName = propertyName;\r\n  }\r\n\r\n  public build = (): ValueValidator<TModel, TValue> => {\r\n    return (value: TValue, model: TModel) => {\r\n      if (value == null || model[this.propertyName as TPropertyName] == null) {\r\n        return null;\r\n      }\r\n\r\n      const valueValidator = this.eachValueValidatorBuilder.build();\r\n\r\n      const errors = (value as Array<TEachValue>).map((element) => {\r\n        const errorOrNull = valueValidator(element, model);\r\n        return hasError(errorOrNull) ? errorOrNull : null;\r\n      }) as ValueValidationResult<TValue>;\r\n\r\n      return hasError<TValue>(errors) ? errors : null;\r\n    };\r\n  };\r\n\r\n  public getAllRules = () => this.eachValueValidatorBuilder.getAllRules();\r\n}\r\n","import { AsyncArrayValueValidatorBuilder } from './valueValidator/AsyncArrayValueValidatorBuilder';\r\nimport { AsyncValueValidatorBuilder } from './valueValidator/AsyncValueValidatorBuilder';\r\nimport { ValidationErrors } from './ValidationErrors';\r\nimport { ArrayValueValidatorBuilder } from './valueValidator/ArrayValueValidatorBuilder';\r\nimport { AsyncRuleValidators } from './valueValidator/RuleValidators';\r\nimport { RuleValidators } from './valueValidator/RuleValidators';\r\nimport { hasError } from './valueValidator/ValueValidator';\r\nimport { ValueValidatorBuilder } from './valueValidator/ValueValidatorBuilder';\r\nimport { ValueValidationResult } from 'ValueValidationResult';\r\nimport { Constrain } from './types/Constrain';\r\nimport { ValueTransformer } from 'valueValidator/ValueTransformer';\r\n\r\ntype ValueValidatorBuildersByPropertyName<TModel> = {\r\n  [propertyName in keyof TModel]?: Array<\r\n    TModel[propertyName] extends Array<infer TEachValue>\r\n      ?\r\n          | ValueValidatorBuilder<\r\n              TModel,\r\n              TModel[propertyName],\r\n              | TModel[propertyName]\r\n              | string\r\n              | number\r\n              | boolean\r\n              | null\r\n              | undefined\r\n              | symbol\r\n            >\r\n          | ArrayValueValidatorBuilder<\r\n              TModel,\r\n              propertyName,\r\n              TModel[propertyName],\r\n              TEachValue,\r\n              TEachValue | string | number | boolean | null | undefined | symbol\r\n            >\r\n      : ValueValidatorBuilder<\r\n          TModel,\r\n          TModel[propertyName],\r\n          | TModel[propertyName]\r\n          | string\r\n          | number\r\n          | boolean\r\n          | null\r\n          | undefined\r\n          | symbol\r\n        >\r\n  >;\r\n};\r\n\r\ntype AsyncValueValidatorBuildersByPropertyName<TModel> = {\r\n  [propertyName in keyof TModel]?: Array<\r\n    TModel[propertyName] extends Array<infer TEachValue>\r\n      ?\r\n          | AsyncValueValidatorBuilder<\r\n              TModel,\r\n              TModel[propertyName],\r\n              | TModel[propertyName]\r\n              | string\r\n              | number\r\n              | boolean\r\n              | null\r\n              | undefined\r\n              | symbol\r\n            >\r\n          | AsyncArrayValueValidatorBuilder<\r\n              TModel,\r\n              propertyName,\r\n              TModel[propertyName],\r\n              TEachValue,\r\n              TEachValue | string | number | boolean | null | undefined | symbol\r\n            >\r\n      : AsyncValueValidatorBuilder<\r\n          TModel,\r\n          TModel[propertyName],\r\n          | TModel[propertyName]\r\n          | string\r\n          | number\r\n          | boolean\r\n          | null\r\n          | undefined\r\n          | symbol\r\n        >\r\n  >;\r\n};\r\n\r\nexport abstract class CoreValidator<TModel, TAsync extends true | false> {\r\n  private _isAsync: TAsync;\r\n\r\n  constructor(isAsync: TAsync) {\r\n    this._isAsync = isAsync;\r\n  }\r\n\r\n  private valueValidatorBuildersByPropertyName: ValueValidatorBuildersByPropertyName<TModel> =\r\n    {};\r\n\r\n  private asyncValueValidatorBuildersByPropertyName: AsyncValueValidatorBuildersByPropertyName<TModel> =\r\n    {};\r\n\r\n  protected _validate: (value: TModel) => ValidationErrors<TModel> = () => {\r\n    return {};\r\n  };\r\n\r\n  protected _validateAsync: (\r\n    value: TModel\r\n  ) => Promise<ValidationErrors<TModel>> = async () => {\r\n    return Promise.resolve({});\r\n  };\r\n\r\n  private rebuildValidate = () => {\r\n    this._validate = (value: TModel): ValidationErrors<TModel> => {\r\n      const errors: ValidationErrors<TModel> = {};\r\n\r\n      for (const propertyName of Object.keys(\r\n        this.valueValidatorBuildersByPropertyName\r\n      )) {\r\n        const valueValidatorBuilders =\r\n          this.valueValidatorBuildersByPropertyName[\r\n            propertyName as keyof TModel\r\n          ];\r\n\r\n        for (const valueValidatorBuilder of valueValidatorBuilders!) {\r\n          const valueValidator = valueValidatorBuilder.build();\r\n\r\n          const result = valueValidator(\r\n            value[propertyName as keyof TModel],\r\n            value\r\n          ) as ValueValidationResult<TModel[keyof TModel]>;\r\n\r\n          if (hasError(result)) {\r\n            errors[propertyName as keyof TModel] = result;\r\n          }\r\n        }\r\n      }\r\n\r\n      return errors;\r\n    };\r\n  };\r\n\r\n  private rebuildValidateAsync = () => {\r\n    this._validateAsync = async (\r\n      value: TModel\r\n    ): Promise<ValidationErrors<TModel>> => {\r\n      const errors: ValidationErrors<TModel> = {};\r\n\r\n      for (const propertyName of Object.keys(\r\n        this.asyncValueValidatorBuildersByPropertyName\r\n      )) {\r\n        const asyncValueValidatorBuilders =\r\n          this.asyncValueValidatorBuildersByPropertyName[\r\n            propertyName as keyof TModel\r\n          ];\r\n\r\n        for (const asyncValueValidatorBuilder of asyncValueValidatorBuilders!) {\r\n          const asyncValueValidator = asyncValueValidatorBuilder.build();\r\n\r\n          const result = (await asyncValueValidator(\r\n            value[propertyName as keyof TModel],\r\n            value\r\n          )) as ValueValidationResult<TModel[keyof TModel]>;\r\n\r\n          if (hasError<TModel[keyof TModel]>(result)) {\r\n            errors[propertyName as keyof TModel] = result;\r\n          }\r\n        }\r\n      }\r\n\r\n      return errors;\r\n    };\r\n  };\r\n\r\n  protected ruleFor = <\r\n    TPropertyName extends keyof TModel,\r\n    TValue extends TModel[TPropertyName]\r\n  >(\r\n    propertyName: TPropertyName\r\n  ): TAsync extends true\r\n    ? AsyncRuleValidators<TModel, TValue>\r\n    : RuleValidators<TModel, TValue> => {\r\n    if (this._isAsync) {\r\n      const asyncValueValidatorBuilder = new AsyncValueValidatorBuilder<\r\n        TModel,\r\n        TValue,\r\n        TValue\r\n      >(this.rebuildValidateAsync, (value) => value);\r\n\r\n      this.asyncValueValidatorBuildersByPropertyName[propertyName] =\r\n        this.asyncValueValidatorBuildersByPropertyName[propertyName] || [];\r\n\r\n      this.asyncValueValidatorBuildersByPropertyName[propertyName]!.push(\r\n        asyncValueValidatorBuilder as any\r\n      );\r\n\r\n      return asyncValueValidatorBuilder.getAllRules() as unknown as AsyncRuleValidators<\r\n        TModel,\r\n        TValue\r\n      > as any; // Appease the type system\r\n    } else {\r\n      const valueValidatorBuilder = new ValueValidatorBuilder<\r\n        TModel,\r\n        TValue,\r\n        TValue\r\n      >(this.rebuildValidate, (value) => value);\r\n\r\n      this.valueValidatorBuildersByPropertyName[propertyName] =\r\n        this.valueValidatorBuildersByPropertyName[propertyName] || [];\r\n\r\n      this.valueValidatorBuildersByPropertyName[propertyName]!.push(\r\n        valueValidatorBuilder as any\r\n      );\r\n\r\n      return valueValidatorBuilder.getAllRules() as unknown as RuleValidators<\r\n        TModel,\r\n        TValue\r\n      > as any; // Appease the type system\r\n    }\r\n  };\r\n\r\n  protected ruleForTransformed = <\r\n    TPropertyName extends keyof TModel,\r\n    TValue extends TModel[TPropertyName],\r\n    // We restrict the type to simple types, otherwise it would be possible to map a simple type\r\n    // to a complex type and force an object/array property in the validation errors, when only\r\n    // a simple property (`string | null`) is expected. `TValue` is also obviously accepted, since\r\n    // the errors object will have the same shape in that case.\r\n    TTransformedValue extends\r\n      | TValue\r\n      | string\r\n      | number\r\n      | boolean\r\n      | null\r\n      | undefined\r\n      | symbol\r\n  >(\r\n    propertyName: TPropertyName,\r\n    transformValue: (\r\n      value: TValue\r\n    ) => TTransformedValue extends object\r\n      ? Constrain<TTransformedValue, TValue>\r\n      : TTransformedValue\r\n  ): TAsync extends true\r\n    ? AsyncRuleValidators<TModel, TTransformedValue>\r\n    : RuleValidators<TModel, TTransformedValue> => {\r\n    if (this._isAsync) {\r\n      const asyncValueValidatorBuilder = new AsyncValueValidatorBuilder<\r\n        TModel,\r\n        TValue,\r\n        TTransformedValue\r\n      >(\r\n        this.rebuildValidateAsync,\r\n        transformValue as ValueTransformer<TValue, TTransformedValue>\r\n      );\r\n\r\n      this.asyncValueValidatorBuildersByPropertyName[propertyName] =\r\n        this.asyncValueValidatorBuildersByPropertyName[propertyName] || [];\r\n\r\n      this.asyncValueValidatorBuildersByPropertyName[propertyName]!.push(\r\n        asyncValueValidatorBuilder as any // Appease the type system\r\n      );\r\n\r\n      return asyncValueValidatorBuilder.getAllRules() as unknown as AsyncRuleValidators<\r\n        TModel,\r\n        TTransformedValue\r\n      > as any; // Appease the type system\r\n    } else {\r\n      const valueValidatorBuilder = new ValueValidatorBuilder<\r\n        TModel,\r\n        TValue,\r\n        TTransformedValue\r\n      >(this.rebuildValidate, transformValue as any);\r\n\r\n      this.valueValidatorBuildersByPropertyName[propertyName] =\r\n        this.valueValidatorBuildersByPropertyName[propertyName] || [];\r\n\r\n      this.valueValidatorBuildersByPropertyName[propertyName]!.push(\r\n        valueValidatorBuilder as any\r\n      );\r\n\r\n      return valueValidatorBuilder.getAllRules() as unknown as RuleValidators<\r\n        TModel,\r\n        TTransformedValue\r\n      > as any; // Appease the type system\r\n    }\r\n  };\r\n\r\n  protected ruleForEach = <\r\n    TPropertyName extends keyof TModel,\r\n    TValue extends TModel[TPropertyName] extends\r\n      | Array<infer TEachValue>\r\n      | ReadonlyArray<infer TEachValue>\r\n      | Readonly<Array<infer TEachValue>>\r\n      | null\r\n      | undefined\r\n      ? TModel[TPropertyName] &\r\n          (\r\n            | Array<TEachValue>\r\n            | ReadonlyArray<TEachValue>\r\n            | Readonly<Array<TEachValue>>\r\n            | null\r\n            | undefined\r\n          )\r\n      : never\r\n  >(\r\n    propertyName: TModel[TPropertyName] extends\r\n      | Array<unknown>\r\n      | ReadonlyArray<unknown>\r\n      | Readonly<Array<unknown>>\r\n      | null\r\n      | undefined\r\n      ? TPropertyName\r\n      : never\r\n  ): TValue extends\r\n    | Array<unknown>\r\n    | ReadonlyArray<unknown>\r\n    | Readonly<Array<unknown>>\r\n    ? TAsync extends true\r\n      ? AsyncRuleValidators<TModel, TValue[0]>\r\n      : RuleValidators<TModel, TValue[0]>\r\n    : never => {\r\n    if (this._isAsync) {\r\n      const asyncArrayValueValidatorBuilder =\r\n        new AsyncArrayValueValidatorBuilder(\r\n          this.rebuildValidateAsync,\r\n          propertyName as string,\r\n          (value) => value\r\n        );\r\n\r\n      if (\r\n        this.asyncValueValidatorBuildersByPropertyName[propertyName] == null\r\n      ) {\r\n        this.asyncValueValidatorBuildersByPropertyName[propertyName] = [];\r\n      }\r\n\r\n      this.asyncValueValidatorBuildersByPropertyName[propertyName]!.push(\r\n        asyncArrayValueValidatorBuilder as any\r\n      );\r\n\r\n      return asyncArrayValueValidatorBuilder.getAllRules() as any;\r\n    } else {\r\n      const arrayValueValidatorBuilder = new ArrayValueValidatorBuilder(\r\n        this.rebuildValidate,\r\n        propertyName as string,\r\n        (value) => value\r\n      );\r\n\r\n      if (this.valueValidatorBuildersByPropertyName[propertyName] == null) {\r\n        this.valueValidatorBuildersByPropertyName[propertyName] = [];\r\n      }\r\n\r\n      this.valueValidatorBuildersByPropertyName[propertyName]!.push(\r\n        arrayValueValidatorBuilder as any\r\n      );\r\n\r\n      return arrayValueValidatorBuilder.getAllRules() as any;\r\n    }\r\n  };\r\n\r\n  protected ruleForEachTransformed = <\r\n    TPropertyName extends keyof TModel,\r\n    TValue extends TModel[TPropertyName] extends\r\n      | Array<infer TEachValue>\r\n      | ReadonlyArray<infer TEachValue>\r\n      | Readonly<Array<infer TEachValue>>\r\n      | null\r\n      | undefined\r\n      ? TModel[TPropertyName] &\r\n          (\r\n            | Array<TEachValue>\r\n            | ReadonlyArray<TEachValue>\r\n            | Readonly<Array<TEachValue>>\r\n            | null\r\n            | undefined\r\n          )\r\n      : never,\r\n    // We restrict the type to simple types, otherwise it would be possible to map a simple type\r\n    // to a complex type and force an object/array property in the validation errors, when only\r\n    // a simple property (`string | null`) is expected. `TValue` is also obviously accepted, since\r\n    // the errors object will have the same shape in that case.\r\n    TEachTransformedValue extends\r\n      | (TValue extends Array<infer TEachValue> ? TEachValue : never)\r\n      | string\r\n      | number\r\n      | boolean\r\n      | null\r\n      | undefined\r\n      | symbol\r\n  >(\r\n    propertyName: TModel[TPropertyName] extends\r\n      | Array<unknown>\r\n      | ReadonlyArray<unknown>\r\n      | Readonly<Array<unknown>>\r\n      | null\r\n      | undefined\r\n      ? TPropertyName\r\n      : never,\r\n    transformValue: (\r\n      value: TModel[TPropertyName] extends\r\n        | Array<infer TEachValue>\r\n        | ReadonlyArray<infer TEachValue>\r\n        | Readonly<Array<infer TEachValue>>\r\n        ? TEachValue\r\n        : never\r\n    ) => TEachTransformedValue extends object\r\n      ? Constrain<\r\n          TEachTransformedValue,\r\n          TModel[TPropertyName] extends\r\n            | Array<infer TEachValue>\r\n            | ReadonlyArray<infer TEachValue>\r\n            | Readonly<Array<infer TEachValue>>\r\n            ? TEachValue\r\n            : never\r\n        >\r\n      : TEachTransformedValue\r\n  ): TValue extends\r\n    | Array<unknown>\r\n    | ReadonlyArray<unknown>\r\n    | Readonly<Array<unknown>>\r\n    ? TAsync extends true\r\n      ? AsyncRuleValidators<TModel, TEachTransformedValue>\r\n      : RuleValidators<TModel, TEachTransformedValue>\r\n    : never => {\r\n    if (this._isAsync) {\r\n      const asyncArrayValueValidatorBuilder =\r\n        new AsyncArrayValueValidatorBuilder(\r\n          this.rebuildValidateAsync,\r\n          propertyName as string,\r\n          transformValue as ValueTransformer<\r\n            TModel[TPropertyName] extends\r\n              | Array<infer TEachValue>\r\n              | ReadonlyArray<infer TEachValue>\r\n              | Readonly<Array<infer TEachValue>>\r\n              ? TEachValue\r\n              : never,\r\n            TEachTransformedValue\r\n          >\r\n        );\r\n\r\n      if (\r\n        this.asyncValueValidatorBuildersByPropertyName[propertyName] == null\r\n      ) {\r\n        this.asyncValueValidatorBuildersByPropertyName[propertyName] = [];\r\n      }\r\n\r\n      this.asyncValueValidatorBuildersByPropertyName[propertyName]!.push(\r\n        asyncArrayValueValidatorBuilder as any\r\n      );\r\n\r\n      return asyncArrayValueValidatorBuilder.getAllRules() as any;\r\n    } else {\r\n      const arrayValueValidatorBuilder = new ArrayValueValidatorBuilder(\r\n        this.rebuildValidate,\r\n        propertyName as string,\r\n        transformValue as any // Appease the type system\r\n      );\r\n\r\n      if (this.valueValidatorBuildersByPropertyName[propertyName] == null) {\r\n        this.valueValidatorBuildersByPropertyName[propertyName] = [];\r\n      }\r\n\r\n      this.valueValidatorBuildersByPropertyName[propertyName]!.push(\r\n        arrayValueValidatorBuilder as any\r\n      );\r\n\r\n      return arrayValueValidatorBuilder.getAllRules() as any;\r\n    }\r\n  };\r\n}\r\n\r\nexport class SyncValidator<TModel> extends CoreValidator<TModel, false> {\r\n  public validate = (value: TModel): ValidationErrors<TModel> => {\r\n    return this._validate(value);\r\n  };\r\n\r\n  constructor() {\r\n    super(false);\r\n  }\r\n}\r\n\r\nexport class AsyncValidator<TModel> extends CoreValidator<TModel, true> {\r\n  public validateAsync = (value: TModel): Promise<ValidationErrors<TModel>> => {\r\n    return this._validateAsync(value);\r\n  };\r\n\r\n  constructor() {\r\n    super(true);\r\n  }\r\n}\r\n"]}